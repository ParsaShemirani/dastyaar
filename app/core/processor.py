#These functions seek to deal with the messages context, add new ones, call functions based on response, generate response.

from typing import List, Dict, Any, Tuple, Optional
import json







def messages_appender(
            fragment: Any,
            fragment_kind: str,
            messages: Any,
            user_input: Optional[str] = None,
            function_output: Optional[Any] = None,
) -> Any:
    """
    Works with a "fragment".The kind of fragment can be a function_call,
    function_call_output, assistant_message, or user_input. Given a response generated by OpenAI,
    a fragment is an item in response.output. In the case of user messages and function_call_outputs,
    the user input or function output and id will be used to append to messages.

    Outputs the new messages list after appending.

    
    """

    if fragment_kind == "function_call" and fragment.type == "function_call":
        messages.append({
            "type": "function_call",
            "id": fragment.id,
            "call_id": fragment.call_id,
            "name": fragment.name,
            "arguments": fragment.arguments
        })
    
    elif fragment_kind == "function_call_output":
        messages.append({
            "type": "function_call_output",
            "call_id": fragment.call_id,
            "output": repr(function_output)
        })

    elif fragment_kind == "assistant_message" and fragment.role == "assistant":
        messages.append({
            "id": fragment.id,
            "role": "assistant",
            "content": [
                {
                    "type": "output_text",
                    "text": fragment.content[0].text
                }
            ]
        })
    
    elif fragment_kind == "user_message":
        messages.append({
            "role": "user",
            "content": [
                {
                    "type": "input_text",
                    "text": user_input
                }
            ]
        })

    return messages

#Related to functions and execution of them
from app.tools.mysql.functions import get_entries

function_registry = {
    "get_entries": get_entries
}





def function_executer(
        fragment: Any,
):
    function_name = fragment.name
    function_args = json.loads(fragment.arguments)
    function_result = function_registry[function_name](**function_args)
    return function_result


#Main handler for responses
def response_handler(
        response,
        messages
) -> Any:
    """
    This function takes a new response from the AI, then calls the necessary functions, and appends function output or assistant
    messages to the current messages, then returns the new message list, as well as wether or not the history should
    route to the AI again before going to user.
    
    """
    saw_function_call = False
    saw_assistant_message = False
    follow_up_needed = False

    for output_item in response.output:
        if output_item.type == "function_call":
            saw_function_call = True
            messages = messages_appender(output_item, "function_call", messages, None, None)

            function_result = function_executer(output_item)

            messages = messages_appender(output_item, "function_call_output", messages, None, function_result)
        elif hasattr(output_item, "role") and output_item.role == "assistant":
            saw_assistant_message = True

            #Print message

            messages = messages_appender(output_item,"assistant",messages,None,None)
    if saw_function_call and not saw_assistant_message:
        follow_up_needed = True

    return (messages,follow_up_needed)



#Printer prototype

def printer(role,assistant_output):
    if role == "assistant":
        text = assistant_output.output[0].content[0].text
        print("\n" + "=" * 80)
        print("Assistant:")
        print(text)
        print("=" * 80 + "\n")
    

    if role == "user":
        print("-" * 80)
    
    if role == "initiator":
        print("\n" + "=" * 80)
        print("AI Assistant (Type 'exit' to quit, 'savemessages' to save conversation)")
        print("=" * 80)


